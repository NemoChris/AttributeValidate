>> 设计文档 v0.1
> 核心思想
	-> 特性就是一个类，验证的规则由特性类实现。
	-> 通过添加特性来确定验证哪些属性。
	-> 特性类元数据的获取通过反射实现。
> 添加特性验证的步骤
		> 新建特性类，3步。 
			1、设置需要验证的程序元素
				[AttributeUsage(AttributeTargets.Property)]
			2、继承Attribute
			3、添加属性和validate方法。
				validate方法
					判断属性的值是否为空。
				属性
					存储属性的值。
					返回的错误消息。
		> 修改model类
			-> 给model类待验证的属性添加特性
			-> 实现model类验证方法
				反射取所有属性的特性，实例化特性进行验证。
				伪代码
					反射取每个属性
					取属性的所有特性
						拿到特性（类）
							1、将属性的值传递给特性
							2、通过特性的验证方法进行验证。
		

>> 设计文档 v1.0
	> 抽象model父类
		> 解决当有多个model类时，model类中的验证方法就重复了。
		> 两种解决方案：
			1、将方法抽离到公用的类中。（静态工具类）
			2、为所有的model抽象出一个父类，父类中添加公用的方法。
			同时为方法提供重写，当子类实现不同时可以重写。
		> 解决方案2优点分析：
			1、方案1，当方法需要不同的实现时，只能通过修改工具类实现。且调用代码需要更改。
				方案2可直接重写父类方法实现，且调用代码不用改。
			2、工具类与Model只有一个调用的关系。而抽象父类和model是继承的关系。我们的功能
			放在抽象父类中比放在工具类更为合理，方法的作用对象都是model的实例。
		综上所述，采用方案2。
		> 设计抽象父类
			-> 父类是所有model的父类，不是具体的某个model,应该是抽象的，无法实例化。->  abstract
			-> 父类中有验证方法，有通用的实现。同时提供给子类进行重写。 -> virtual
	> 有多个验证特性类时，特性类的方法和属性都重复了。
	且model的验证方法，只能取到一个指定的特性实例。
	> 解决方案：抽象出特性类父类。将公用的成员放入父类。
	且更改model验证类型为特性类父类，如此特性类及其子类的实例都可以取到。
	> 特性父类设计
		> 是所有验证类抽象集合，无具体的实现。
		> 有固定的属性。
		> 验证方法由子类实现，也是抽象的。





